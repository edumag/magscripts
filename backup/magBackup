#!/bin/bash

## magBackup - Sistema de copias de seguridad automáticas con backups incrementales
##
## Facilita la creación de copias de seguridad automáticas para archivos, bases de datos
## MySQL y PostgreSQL, tanto locales como en contenedores Docker o Dokku.
##
## SISTEMA DE BACKUPS:
## - Copias MENSUALES completas: Una copia completa por mes (nombre-mes.tar.bz2)
## - Copias DIARIAS incrementales: Solo cambios desde la última mensual (nombre-YYYYMMDD_HHMMSS.tar.bz2)
## - Snapshots de tar: Archivos de metadatos para seguimiento de cambios (.snapshots/)
## - Verificación SHA256: Checksums para validar integridad (.sha256)
##
## RETENCIÓN INTELIGENTE (configurable):
## - Diarias: 7 copias (por defecto)
## - Semanales: 4 copias (por defecto)
## - Mensuales: 12 copias (por defecto)
##
## USO:
##   magBackup [opciones]
##
## OPCIONES:
##   -h, --help              Muestra esta ayuda
##   --config, -c            Configurar directorio de backups y retención
##   --listar, -l            Listar todos los perfiles y sus backups
##   --backup-dir, -b        Especificar directorio de backups (útil sin configuración)
##   --recuperar, -r         Recuperar un backup completo
##                           Uso: --recuperar <perfil|nombre> [fecha] [destino]
##                           Funciona con perfiles configurados o backups sueltos
##                           Sin fecha: recupera mensual + todos los incrementales
##                           Con fecha: recupera mensual + incrementales hasta esa fecha
##                           Ejemplos:
##                             --recuperar documentos
##                             --recuperar documentos 20260212
##                             --recuperar documentos 20260212 /tmp/destino
##   --dependencias, -d      Comprobar dependencias instaladas
##
## CONFIGURACIÓN DE PERFILES:
##
## 1. Archivos y carpetas (~/.config/magscripts/magBackup/ficheros/nombre_perfil):
##    CS_DIR="$HOME"
##    CS_COPIAR="Scripts .bashrc Documents"
##
## 2. MySQL local (~/.config/magscripts/magBackup/mysql/nombre_bd):
##    USUARIO="root"
##    PASS="contraseña"
##    BASES_DATOS="basedato1 basedato2"
##
## 3. PostgreSQL en Docker (~/.config/magscripts/magBackup/docker_postgres/nombre):
##    DOCKER_IMAGE="postgres_container"
##    DOCKER_USER="postgres"
##    DOCKER_PASSWORD="contraseña"
##    DOCKER_DATABASE="mi_db"
##
## 4. PostgreSQL en Dokku (~/.config/magscripts/magBackup/dokku_postgres/nombre):
##    DOKKU_APP="nombre_app"
##
## 5. MySQL en Dokku (~/.config/magscripts/magBackup/dokku_mysql/nombre):
##    DOKKU_APP="nombre_app"
##
## EJEMPLOS DE USO:
##
##   # Crear todos los backups configurados
##   magBackup
##
##   # Ver perfiles y backups disponibles
##   magBackup --listar
##
##   # Recuperar estado más reciente (mensual + todos los incrementales)
##   magBackup --recuperar documentos
##
##   # Recuperar estado hasta una fecha específica
##   # (mensual base + incrementales hasta el 12/02/2026)
##   magBackup --recuperar documentos 20260212
##
##   # Recuperar en un directorio específico
##   magBackup --recuperar documentos 20260212 /tmp/recuperado
##
## RECUPERACIÓN SIN PERFIL:
##   También puedes recuperar backups que existen en cualquier directorio, incluso
##   sin tener perfil configurado ni archivo de configuración.
##
##   # Especificar directorio de backups y recuperar
##   magBackup --backup-dir /mnt/backups/antiguos --recuperar config
##
##   # O con fecha específica
##   magBackup --backup-dir /mnt/backups --recuperar documentos 20260212
##
## CONFIGURACIÓN AVANZADA (variables en ~/.config/magscripts/magBackup/config):
##   magBackup_dir="$HOME/backup/"      # Directorio de destino
##   RETENTION_DAILY=7                   # Copias diarias a mantener
##   RETENTION_WEEKLY=4                  # Copias semanales a mantener
##   RETENTION_MONTHLY=12                # Copias mensuales a mantener

## @var magBackup_dir
## Directorio donde guardar las copias realizadas
magBackup_dir="$HOME/backup/"

help() { $(dirname "$BASH_SOURCE")/../lib/doxygen2help "$0" ; }

# variables internas

DAYS_TO_DELETE=90
DIR_CONFIG_MAGBACKUP="$HOME/.config/magscripts/magBackup"
fichero_configuracion_magbackup="$DIR_CONFIG_MAGBACKUP/config"  ##< Fichero configuración
directorio__ficheros="$DIR_CONFIG_MAGBACKUP/ficheros/"  ##< Fichero configuración
directorio__mysql="$DIR_CONFIG_MAGBACKUP/mysql/"  ##< Fichero configuración
directorio__docker_postgres="$DIR_CONFIG_MAGBACKUP/docker_postgres/"  ##< Fichero configuración
directorio__dokku_postgres="$DIR_CONFIG_MAGBACKUP/dokku_postgres/"  ##< Fichero configuración
directorio__dokku_mysql="$DIR_CONFIG_MAGBACKUP/dokku_mysql/"  ##< Fichero configuración

# Configuración de retención de backups
## @var RETENTION_DAILY
## Número de copias diarias a mantener (default: 7)
RETENTION_DAILY=7

## @var RETENTION_WEEKLY
## Número de copias semanales a mantener (default: 4)
RETENTION_WEEKLY=4

## @var RETENTION_MONTHLY
## Número de copias mensuales a mantener (default: 12)
RETENTION_MONTHLY=12

MES=$(date +%B)
DIA=$(date +%A)
DATE=$(date +%Y-%m-%d)

source "$(dirname "$BASH_SOURCE")/../lib/configuracion"

## Recoger configuración de magBackup
[[ -e $fichero_configuracion_magbackup ]] && source "$fichero_configuracion_magbackup"

## @var DIR_SNAPSHOTS
## Directorio para almacenar los archivos de snapshot de tar
## Se guardan en el directorio de backups para mantenerlos junto a las copias
## Se define DESPUÉS de leer la configuración para usar el magBackup_dir correcto
DIR_SNAPSHOTS="${magBackup_dir}.snapshots/"

function magLogger() {
if [ "$1" = "error" ] ; then
  logger -p local0.err -it magBackup "$@"
else
  logger -p local0.info -it magBackup "$@"
fi
}

function magbackup_crear_copia_ficheros_perfil() {

echo --------
echo Ficheros
echo --------

# Crear directorio de snapshots si no existe
if [ ! -d "$DIR_SNAPSHOTS" ]; then
    mkdir -p "$DIR_SNAPSHOTS"
fi

for file in "$directorio__ficheros"* ; do

  [[ ${file:0-1} == '*' ]] && break

    source "$file"

    NOMBRE="$(basename "$file")"
    NOMBRE_MES="${NOMBRE}-$(hostname)-${MES}.tar.bz2"
    FECHA_COMPLETA=$(date +%Y%m%d_%H%M%S)
    NOMBRE_SNAPSHOT="${NOMBRE}-$(hostname)-${FECHA_COMPLETA}.tar.bz2"
    SNAPSHOT_FILE="${DIR_SNAPSHOTS}/${NOMBRE}.snapshot"

    echo
    echo "$NOMBRE"
    printf '%s\n' "$NOMBRE" | sed 's/./-/g'
    echo
    echo "Inicio:  $CS_DIR"
    echo "Mensual: $NOMBRE_MES"
    echo "Snapshot: $NOMBRE_SNAPSHOT"
    echo

    cd "$CS_DIR" || exit

    if [ ! -d "$CS_DIR" ] ; then echo "Directorio de inicio $CS_DIR no existe!" ; exit 1 ; fi

    for origenes in $CS_COPIAR ; do
      if [ -e "$origenes" ] ; then
        echo -e "$origenes OK"
      else
        errores="$errores $origenes"
        magLogger error "No se encuentra $origenes"
      fi
    done

    if [ "$errores" != "" ] ; then
      echo
      echo Hay ubicaciones por copiar que no existen
      echo
      echo "$errores" | tr ' ' "\n"
      exit 1
    fi

    # Determinar si es copia mensual completa o diaria incremental
    ANYO_ACTUAL=$(date +%Y)
    ES_MES_NUEVO=false

    if [ -e "${magBackup_dir}$NOMBRE_MES" ]; then
        ANYO_COPIA=$(date +%Y -r "${magBackup_dir}$NOMBRE_MES")
        if [ "$ANYO_ACTUAL" != "$ANYO_COPIA" ]; then
            ES_MES_NUEVO=true
        fi
    else
        ES_MES_NUEVO=true
    fi

    # Directorio temporal para copia atómica
    DIR_TEMP=$(mktemp -d)
    TEMP_DESTINO="${DIR_TEMP}/backup.tar.bz2"

    if [ "$ES_MES_NUEVO" = true ]; then
        # Generamos copia mensual completa
        DESTINO="${magBackup_dir}$NOMBRE_MES"
        CMD="nice -10 tar -Pcjpf '$TEMP_DESTINO' --listed-incremental='$SNAPSHOT_FILE' $CS_COPIAR"

        echo
        echo "Realizamos copia mensual completa: $NOMBRE_MES"
        echo "Snapshot: $SNAPSHOT_FILE"
        echo
    else
        # Generamos copia diaria incremental
        DESTINO="${magBackup_dir}$NOMBRE_SNAPSHOT"
        CMD="nice -10 tar -Pcjpf '$TEMP_DESTINO' --listed-incremental='$SNAPSHOT_FILE' $CS_COPIAR"

        echo
        echo "Realizamos copia diaria incremental: $NOMBRE_SNAPSHOT"
        echo "Snapshot: $SNAPSHOT_FILE"
        echo
    fi

    echo
    echo "Comando: $CMD"
    echo
    eval "$CMD"
    RESULTADO=$?

    if [ $RESULTADO = 0 ] ; then
        # Mover la copia del directorio temporal al destino final
        if mv "$TEMP_DESTINO" "$DESTINO"; then
            # Generar checksum
            CHECKSUM_FILE="${DESTINO}.sha256"
            sha256sum "$DESTINO" > "$CHECKSUM_FILE"
            echo "Checksum generado: $CHECKSUM_FILE"

            echo "Copia generada correctamente"
            magLogger "Copia generada correctamente [${DESTINO}]"

            # Aplicar rotación inteligente
            rotacion_backup "$NOMBRE"
        else
            echo "Error al mover copia al destino final"
            magLogger error "Error al mover copia al destino final [${DESTINO}]"
            rm -f "$TEMP_DESTINO"
            rmdir "$DIR_TEMP"
            exit 1
        fi
    else
        echo "Error al generar copia"
        magLogger error "Error al generar copia [${DESTINO}]"
        rm -f "$TEMP_DESTINO"
        rmdir "$DIR_TEMP"
        exit 1
    fi

    # Limpiar directorio temporal
    rmdir "$DIR_TEMP"

  done

}

function magbackup_crear_copia_mysql_perfil() {

  for file in "$directorio__mysql"* ; do

    [[ ${file:0-1} == '*' ]] && break

    echo
    echo "-----"
    echo "Mysql"
    echo "-----"
    echo

    source "$file"

    for BD in $BASES_DATOS ; do
      cmd="nice -10 mysqldump -u$USUARIO -p$PASS $BD | nice -10 bzip2 --best -c > ${magBackup_dir}mysql-${BD}-$(hostname)-${DIA}.dump.bz2"
      echo
      echo "Comando: $cmd"
      if eval "$cmd"; then
        echo "Copia generada correctamente"
        magLogger "Copia mysql generada correctamente [${BD}]"
      else
        echo "Error al generar copia"
        magLogger error "Error al generar copia de mysql [${BD}]"
        exit 1
        fi
      done

    done

  }

  function magbackup_crear_copia_docker_postgres_perfil() {

    for file in "$directorio__docker_postgres"* ; do

      [[ ${file:0-1} == '*' ]] && break

      echo
      echo "---------------"
      echo "Docker Postgres"
      echo "---------------"
      echo

      source "$file"

      for BD in $BASES_DATOS ; do
        cmd="nice -10 docker exec -i -e PGPASSWORD=${DOCKER_PASSWORD} ${DOCKER_IMAGE} /usr/bin/pg_dump -U ${DOCKER_USER} ${DOCKER_DATABASE} > ${magBackup_dir}docker_postgres-${DOCKER_DATABASE}-$(hostname)-${DIA}.dump"
        echo
        echo "Comando: $cmd"
        if eval "$cmd"; then
          echo "Copia generada correctamente"
          magLogger "Copia postgres docker generada correctamente [${DOCKER_DATABASE}]"
        else
          echo "Error al generar copia"
          magLogger error "Error al generar copia de postgres docker [${DOCKER_DATABASE}]"
          exit 1
        fi
      done

    done

  }

  function magbackup_crear_copia_dokku_postgres_perfil() {

    for file in "$directorio__dokku_postgres"* ; do

      [[ ${file:0-1} == '*' ]] && break

      echo
      echo "--------------"
      echo "Dokku Postgres"
      echo "--------------"
      echo
      echo "$file"

      source "$file"
      DESTINO="${magBackup_dir}dokku_postgres-${DOKKU_APP}-$(hostname)-${DATE}.sql"

      # cmd="nice -10 dokku postgres:export $DOKKU_APP > $DESTINO"
      # Dokku postgres solo hace la exportación de la base de datos con el mismo nombre que la app.
      # Utilizamos docker directamente para tener una copia total de la base de datos.
      # TAG=$(docker ps --format table | grep $DOKKU_APP | awk -F " " '{print $NF}')
      TAG="dokku.postgres.$DOKKU_APP"
      if [ -z "$TAG" ] ; then
        echo "No se encuentra contenedor postgres en docker [${DOKKU_APP}]"
        magLogger error "No se encuentra contenedor postgres en docker [${DOKKU_APP}]"
        exit 1
      fi
      cmd="nice -10 docker exec -t $TAG pg_dumpall -c -U postgres > $DESTINO"
      echo
      echo "Comando: $cmd"
      if eval "$cmd"; then
        if bzip2 -f "$DESTINO"; then
          echo "Copia generada correctamente"
          magLogger "Copia postgres en dokku generada correctamente [${DOKKU_APP}]"
        else
          echo "Error al comprimir copia."
          magLogger error "Error al comprimir copia postgres en dokku [${DOKKU_APP}]"
          exit 1
        fi
      else
        echo "Error al generar copia"
        magLogger error "Error al generar copia postgres en dokku [${DOKKU_APP}]"
        exit 1
    fi

  done

}

function magbackup_crear_copia_dokku_mysql_perfil() {

  for file in "$directorio__dokku_mysql"* ; do

    [[ ${file:0-1} == '*' ]] && break

    echo
    echo "-----------"
    echo "Dokku MySQL"
    echo "-----------"
    echo
    echo "$file"

    source "$file"

    DESTINO="${magBackup_dir}dokku_mysql-${DOKKU_APP}-$(hostname)-${DATE}.sql"
    cmd="nice -10 dokku mysql:export $DOKKU_APP > $DESTINO"
    echo
    echo "Comando: $cmd"
    if eval "$cmd"; then
      if bzip2 -f "$DESTINO"; then
        echo "Copia generada correctamente"
        magLogger "Copia mysql en dokku generada correctamente [${DOKKU_APP}]"
      else
        echo "Error al comprimir copia."
        magLogger error "Error al comprimir copia mysql en dokku [${DOKKU_APP}]"
        exit 1
      fi
    else
      echo "Error al generar copia"
      magLogger error "Error al generar copia mysql en dokku [${DOKKU_APP}]"
      exit 1
    fi

  done

}

## @function verificar_backup
## @brief Verifica la integridad de un backup usando su checksum SHA256
## @param $1 Ruta al archivo de backup
## @return 0 si es válido, 1 si es inválido
function verificar_backup() {
    local backup_file="$1"
    local checksum_file="${backup_file}.sha256"

    if [ ! -f "$backup_file" ]; then
        echo "Error: No se encuentra el archivo de backup $backup_file"
        return 1
    fi

    if [ ! -f "$checksum_file" ]; then
        echo "Advertencia: No se encuentra el archivo de checksum $checksum_file"
        return 1
    fi

    echo "Verificando integridad de $backup_file..."
    if sha256sum -c "$checksum_file" > /dev/null 2>&1; then
        echo "✓ Verificación exitosa: $backup_file"
        return 0
    else
        echo "✗ ERROR: Verificación fallida para $backup_file"
        magLogger error "Verificación de integridad fallida para $backup_file"
        return 1
    fi
}

## @function rotacion_backup
## @brief Aplica rotación inteligente de backups manteniendo N diarias, M semanales y P mensuales
## @param $1 Prefijo del nombre del backup (perfil)
function rotacion_backup() {
    local prefix="$1"
    local hostname_suffix
    hostname_suffix=$(hostname)

    echo "Aplicando rotación inteligente para $prefix..."

    # Obtener lista de backups ordenados por fecha (más recientes primero)
    local -a all_backups
    mapfile -t all_backups < <(ls -1t "${magBackup_dir}${prefix}-${hostname_suffix}"-*.tar.bz2 2>/dev/null | grep -E '\.[0-9]{8}_[0-9]{6}\.tar\.bz2$' || true)

    if [ ${#all_backups[@]} -eq 0 ]; then
        echo "No se encontraron backups diarios para rotar"
        return 0
    fi

    # Clasificar backups
    declare -a daily_backups
    declare -a weekly_backups
    declare -a monthly_backups
    declare -A seen_weeks
    declare -A seen_months

    for backup in "${all_backups[@]}"; do
        # Extraer fecha del nombre del archivo (formato: YYYYMMDD_HHMMSS)
        local date_str
        date_str=$(echo "$backup" | grep -oE '[0-9]{8}_[0-9]{6}')
        local year=${date_str:0:4}
        local month=${date_str:4:2}
        local day=${date_str:6:2}
        local week
        week=$(date -d "${year}-${month}-${day}" +%V 2>/dev/null || echo "00")

        local month_key="${year}-${month}"
        local week_key="${year}-${week}"

        # Primero intentar clasificar como mensual
        if [ -z "${seen_months[$month_key]}" ]; then
            monthly_backups+=("$backup")
            seen_months[$month_key]=1
        # Luego como semanal
        elif [ -z "${seen_weeks[$week_key]}" ]; then
            weekly_backups+=("$backup")
            seen_weeks[$week_key]=1
        # Resto como diario
        else
            daily_backups+=("$backup")
        fi
    done

    # Eliminar excedentes de diarias
    if [ ${#daily_backups[@]} -gt $RETENTION_DAILY ]; then
        echo "Eliminando ${#daily_backups[@]} copias diarias antiguas (manteniendo $RETENTION_DAILY)..."
        local i
        for ((i=RETENTION_DAILY; i<${#daily_backups[@]}; i++)); do
            local old_backup="${daily_backups[$i]}"
            echo "  Eliminando: $(basename "$old_backup")"
            rm -f "$old_backup" "${old_backup}.sha256"
        done
    fi

    # Eliminar excedentes de semanales
    if [ ${#weekly_backups[@]} -gt $RETENTION_WEEKLY ]; then
        echo "Eliminando ${#weekly_backups[@]} copias semanales antiguas (manteniendo $RETENTION_WEEKLY)..."
        local i
        for ((i=RETENTION_WEEKLY; i<${#weekly_backups[@]}; i++)); do
            local old_backup="${weekly_backups[$i]}"
            echo "  Eliminando: $(basename "$old_backup")"
            rm -f "$old_backup" "${old_backup}.sha256"
        done
    fi

    # Eliminar excedentes de mensuales
    if [ ${#monthly_backups[@]} -gt $RETENTION_MONTHLY ]; then
        echo "Eliminando ${#monthly_backups[@]} copias mensuales antiguas (manteniendo $RETENTION_MONTHLY)..."
        local i
        for ((i=RETENTION_MONTHLY; i<${#monthly_backups[@]}; i++)); do
            local old_backup="${monthly_backups[$i]}"
            echo "  Eliminando: $(basename "$old_backup")"
            rm -f "$old_backup" "${old_backup}.sha256"
        done
    fi

    echo "Rotación completada. Mantenidas: ${#daily_backups[@]} diarias, ${#weekly_backups[@]} semanales, ${#monthly_backups[@]} mensuales"
}

## @function rotacion_todos_backups
## @brief Aplica rotación a todos los perfiles de backup configurados
function rotacion_todos_backups() {
    echo "Aplicando rotación inteligente a todos los perfiles..."

    for file in "$directorio__ficheros"* ; do
        [[ ${file:0-1} == '*' ]] && break
        local nombre
        nombre="$(basename "$file")"
        rotacion_backup "$nombre"
    done
}

function config() {
  configuracion_editar magBackup_ "$BASH_SOURCE"
  configuracion_guardar "magBackup_" "$fichero_configuracion_magbackup"

}

function delete_old_files() {
  echo "Eliminando copias antiguas (método legacy)..."
  find "$magBackup_dir" -mtime +$DAYS_TO_DELETE -type f \( -name '*tar*' -o -name '*dump' \) -delete 2>/dev/null
  find "$magBackup_dir" -mtime +$DAYS_TO_DELETE -type f -name '*.sha256' -delete 2>/dev/null

  # Aplicar también la nueva rotación inteligente
  rotacion_todos_backups
}

## @function magbackup_recuperar_backup
## @brief Recupera un backup completo (mensual + incrementales hasta la fecha especificada)
## @param $1 Nombre del perfil a recuperar
## @param $2 Fecha hasta la que recuperar en formato YYYYMMDD (opcional)
##                   Si se especifica, recupera el mensual base + todos los incrementales hasta esa fecha
##                   Si no se especifica, muestra lista y permite seleccionar
## @param $3 Directorio destino donde restaurar (opcional, por defecto carpeta actual)
function magbackup_recuperar_backup() {
	local perfil="$1"
	local fecha_hasta="${2:-}"
	local destino="${3:-}"
	local hostname_suffix
	hostname_suffix=$(hostname)

	if [ -z "$perfil" ]; then
		echo "Error: Debes especificar el nombre del perfil a recuperar"
		echo "Uso: magBackup --recuperar <perfil> [fecha] [directorio_destino]"
		echo ""
		echo "Ejemplos:"
		echo "  magBackup --recuperar documentos                  # Muestra lista de backups disponibles"
		echo "  magBackup --recuperar documentos 20260210         # Recupera mensual + incrementales hasta 10/02/2026"
		echo "  magBackup --recuperar documentos 20260210 /tmp    # Recupera en /tmp"
		return 1
	fi

	# Verificar si existe el perfil configurado
	local perfil_file="${directorio__ficheros}${perfil}"
	local perfil_existe=false
	if [ -f "$perfil_file" ]; then
		perfil_existe=true
	fi

	echo "=========================================="
	if [ "$perfil_existe" = true ]; then
		echo "Recuperando backup del perfil: $perfil"
	else
		echo "Recuperando backup (sin perfil): $perfil"
		echo "Nota: No se encontró configuración del perfil, se usarán solo los archivos de backup"
	fi
	echo "=========================================="
	echo

	# Buscar TODOS los backups disponibles
	local -a mensuales
	local -a incrementales
	local -a todos_backups

	# Mensuales (patrón: perfil-host-mes.tar.bz2)
	for backup in "${magBackup_dir}${perfil}-${hostname_suffix}"-*.tar.bz2; do
		[ -e "$backup" ] || continue
		if [[ "$(basename "$backup")" =~ -[A-Za-z]+\.tar\.bz2$ ]]; then
			mensuales+=("$backup")
			todos_backups+=("$backup")
		fi
	done

	# Incrementales con hostname (patrón: perfil-host-YYYYMMDD_HHMMSS.tar.bz2)
	for backup in "${magBackup_dir}${perfil}-${hostname_suffix}"-[0-9]*_*.tar.bz2; do
		[ -e "$backup" ] || continue
		if [[ "$(basename "$backup")" =~ -[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
			incrementales+=("$backup")
			todos_backups+=("$backup")
		fi
	done

	# Incrementales antiguos sin hostname (patrón: perfil-YYYYMMDD_HHMMSS.tar.bz2)
	for backup in "${magBackup_dir}${perfil}"-[0-9]*_*.tar.bz2; do
		[ -e "$backup" ] || continue
		local basename_backup
		basename_backup=$(basename "$backup")
		local duplicado=false
		for existing in "${todos_backups[@]}"; do
			if [ "$(basename "$existing")" = "$basename_backup" ]; then
				duplicado=true
				break
			fi
		done
		if [ "$duplicado" = false ] && [[ "$basename_backup" =~ ^${perfil}-[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
			incrementales+=("$backup")
			todos_backups+=("$backup")
		fi
	done

	# Mostrar lista de backups disponibles
	echo "Backups disponibles:"
	echo "--------------------"
	echo

	# Mostrar mensuales
	echo "1. Copias mensuales completas:"
	if [ ${#mensuales[@]} -gt 0 ]; then
		IFS=$'\n' sorted_mensuales=($(printf '%s\n' "${mensuales[@]}" | sort -k1,1))
		unset IFS
		local i=1
		for backup in "${sorted_mensuales[@]}"; do
			local size fecha
			size=$(du -h "$backup" 2>/dev/null | cut -f1)
			fecha=$(stat -c %y "$backup" 2>/dev/null | cut -d' ' -f1)
			echo "   [$i] $(basename "$backup") ($size) - $fecha"
			i=$((i+1))
		done
	else
		echo "   (ninguna)"
	fi
	echo

	# Mostrar incrementales
	echo "2. Copias incrementales:"
	if [ ${#incrementales[@]} -gt 0 ]; then
		IFS=$'\n' sorted_incrementales=($(printf '%s\n' "${incrementales[@]}" | sort -k1,1))
		unset IFS
		local i=1
		for backup in "${sorted_incrementales[@]}"; do
			local size fecha_hora fecha_formateada
			size=$(du -h "$backup" 2>/dev/null | cut -f1)
			fecha_hora=$(basename "$backup" | grep -oE '[0-9]{8}_[0-9]{6}')
			fecha_formateada=$(echo "$fecha_hora" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)_\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
			echo "   [$i] $(basename "$backup") ($size) - $fecha_formateada"
			i=$((i+1))
		done
	else
		echo "   (ninguna)"
	fi
	echo

	if [ ${#todos_backups[@]} -eq 0 ]; then
		echo "Error: No se encontró ningún backup para el perfil '$perfil'"
		return 1
	fi

	# Determinar qué recuperar
	declare -a backups_a_recuperar
	local tipo_recuperacion=""

	if [ -n "$fecha_hasta" ]; then
		# Usar fecha especificada
		if [[ ! "$fecha_hasta" =~ ^[0-9]{8}$ ]]; then
			echo "Error: La fecha debe tener formato YYYYMMDD (ejemplo: 20260210)"
			return 1
		fi

		echo "Recuperando estado hasta: $fecha_hasta"
		tipo_recuperacion="completo (hasta $fecha_hasta)"
		echo

		# Encontrar mensual base (el más reciente anterior a la fecha)
		local mensual_base=""
		local fecha_hasta_ts
		fecha_hasta_ts=$(date -d "$fecha_hasta 23:59:59" +%s 2>/dev/null)

		for backup in "${sorted_mensuales[@]}"; do
			local fecha_backup
			fecha_backup=$(stat -c %Y "$backup" 2>/dev/null)
			if [ -n "$fecha_backup" ] && [ -n "$fecha_hasta_ts" ]; then
				if [ "$fecha_backup" -le "$fecha_hasta_ts" ]; then
					mensual_base="$backup"
				fi
			fi
		done

		if [ -z "$mensual_base" ]; then
			echo "Error: No se encontró un backup mensual base anterior a $fecha_hasta"
			return 1
		fi

		backups_a_recuperar+=("$mensual_base")

		# Encontrar incrementales entre mensual y fecha límite
		local fecha_mensual_ts
		fecha_mensual_ts=$(stat -c %Y "$mensual_base" 2>/dev/null)

		local -a incs_a_recuperar
		for backup in "${sorted_incrementales[@]}"; do
			local fecha_backup
			fecha_backup=$(stat -c %Y "$backup" 2>/dev/null)
			if [ -n "$fecha_backup" ] && [ -n "$fecha_mensual_ts" ] && [ -n "$fecha_hasta_ts" ]; then
				if [ "$fecha_backup" -gt "$fecha_mensual_ts" ] && [ "$fecha_backup" -le "$fecha_hasta_ts" ]; then
					incs_a_recuperar+=("$backup")
				fi
			fi
		done

		# Añadir incrementales
		for inc in "${incs_a_recuperar[@]}"; do
			backups_a_recuperar+=("$inc")
		done

	else
		# No se especificó fecha - usar mensual más reciente + todos los incrementales posteriores
		echo "No se especificó fecha. Recuperando estado más reciente..."
		tipo_recuperacion="completo (estado más reciente)"
		echo

		if [ ${#sorted_mensuales[@]} -eq 0 ]; then
			echo "Error: No hay backups mensuales disponibles"
			return 1
		fi

		# Mensual más reciente
		local mensual_reciente="${sorted_mensuales[-1]}"
		backups_a_recuperar+=("$mensual_reciente")

		# Todos los incrementales posteriores al mensual
		local fecha_mensual_ts
		fecha_mensual_ts=$(stat -c %Y "$mensual_reciente" 2>/dev/null)

		if [ -n "$fecha_mensual_ts" ]; then
			for backup in "${sorted_incrementales[@]}"; do
				local fecha_backup
				fecha_backup=$(stat -c %Y "$backup" 2>/dev/null)
				if [ -n "$fecha_backup" ] && [ "$fecha_backup" -gt "$fecha_mensual_ts" ]; then
					backups_a_recuperar+=("$backup")
				fi
			done
		fi
	fi

	# Mostrar lista de backups a recuperar
	echo "Backups seleccionados para recuperación:"
	echo "----------------------------------------"
	local count=1
	for backup in "${backups_a_recuperar[@]}"; do
		if [ $count -eq 1 ]; then
			echo "  [$count] $(basename "$backup") (MENSUAL BASE)"
		else
			echo "  [$count] $(basename "$backup") (incremental)"
		fi
		count=$((count+1))
	done
	echo

	# Verificar integridad
	echo "Verificando integridad de los backups..."
	echo "-----------------------------------------"
	local todos_ok=true
	for backup in "${backups_a_recuperar[@]}"; do
		local checksum_file="${backup}.sha256"
		if [ -f "$checksum_file" ]; then
			if ! verificar_backup "$backup" >/dev/null 2>&1; then
				echo "  ✗ $(basename "$backup") - CORRUPTO"
				todos_ok=false
			else
				echo "  ✓ $(basename "$backup") - OK"
			fi
		else
			echo "  ⚠ $(basename "$backup") - Sin checksum"
		fi
	done
	echo

	if [ "$todos_ok" = false ]; then
		echo "Error: Algunos backups están corruptos. No se puede recuperar."
		return 1
	fi

	# Determinar directorio de destino (por defecto: carpeta actual)
	if [ -z "$destino" ]; then
		destino="$PWD"
		echo "Restaurando en carpeta actual: $destino"
	else
		echo "Restaurando en: $destino"
	fi

	# Crear directorio destino si no existe
	if [ ! -d "$destino" ]; then
		echo "Creando directorio destino: $destino"
		mkdir -p "$destino" || {
			echo "Error: No se pudo crear el directorio destino"
			return 1
		}
	fi

	# Confirmar recuperación
	echo
	echo "==============================================="
	echo "Estás a punto de recuperar:"
	echo "  Tipo: $tipo_recuperacion"
	echo "  Total de backups: ${#backups_a_recuperar[@]}"
	echo "  Destino: $destino"
	echo "==============================================="
	read -rp "¿Continuar con la recuperación? (s/n): " confirmar

	if [ "$confirmar" != "s" ] && [ "$confirmar" != "S" ]; then
		echo "Recuperación cancelada"
		return 0
	fi

	# Realizar recuperación aplicando backups en orden
	echo
	echo "Iniciando recuperación..."
	echo

	local exito=true
	local count=0
	for backup in "${backups_a_recuperar[@]}"; do
		count=$((count + 1))
		echo "[$count/${#backups_a_recuperar[@]}] Extrayendo $(basename "$backup")..."

		if tar -xjpf "$backup" -C "$destino"; then
			echo "    ✓ Extraído correctamente"
		else
			echo "    ✗ Error al extraer"
			exito=false
			break
		fi
	done

	echo
	if [ "$exito" = true ]; then
		echo "✓ Recuperación completada exitosamente"
		echo "Archivos restaurados en: $destino"
		magLogger "Backup recuperado exitosamente [${perfil}] - ${tipo_recuperacion} - en [${destino}]"
		return 0
	else
		echo "✗ Error durante la recuperación"
		echo "Se extrajeron $count de ${#backups_a_recuperar[@]} backups"
		magLogger error "Error al recuperar backup [${perfil}] - ${tipo_recuperacion}"
		return 1
	fi
}

## @function magbackup_descubrir_backups
## @brief Descubre backups en el directorio de backups sin necesidad de perfiles configurados
## @return Lista de nombres de perfiles encontrados en los archivos de backup
function magbackup_descubrir_backups() {
    local hostname_suffix
    hostname_suffix=$(hostname)
    local -a perfiles_encontrados

    # Buscar todos los archivos .tar.bz2 en el directorio de backups
    for backup in "${magBackup_dir}"*.tar.bz2; do
        [ -e "$backup" ] || continue
        local basename_backup
        basename_backup=$(basename "$backup")

        # Extraer el nombre del perfil del archivo
        local perfil=""

        # Patrón: perfil-host-mes.tar.bz2 (mensual con hostname)
        if [[ "$basename_backup" =~ ^(.+)-${hostname_suffix}-[A-Za-z]+\.tar\.bz2$ ]]; then
            perfil="${BASH_REMATCH[1]}"
        # Patrón: perfil-host-YYYYMMDD_HHMMSS.tar.bz2 (incremental con hostname)
        elif [[ "$basename_backup" =~ ^(.+)-${hostname_suffix}-[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
            perfil="${BASH_REMATCH[1]}"
        # Patrón: perfil-YYYYMMDD_HHMMSS.tar.bz2 (incremental antiguo sin hostname)
        elif [[ "$basename_backup" =~ ^(.+)-[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
            perfil="${BASH_REMATCH[1]}"
        fi

        # Añadir a la lista si no está duplicado
        if [ -n "$perfil" ]; then
            local duplicado=false
            for existing in "${perfiles_encontrados[@]}"; do
                if [ "$existing" = "$perfil" ]; then
                    duplicado=true
                    break
                fi
            done
            if [ "$duplicado" = false ]; then
                perfiles_encontrados+=("$perfil")
            fi
        fi
    done

    # Retornar la lista
    printf '%s\n' "${perfiles_encontrados[@]}"
}

## @function magbackup_listar_perfiles
## @brief Muestra la lista de perfiles disponibles y sus backups
function magbackup_listar_perfiles() {
    echo "=========================================="
    echo "Perfiles de backup configurados"
    echo "=========================================="
    echo

    local hostname_suffix
    hostname_suffix=$(hostname)

    for file in "$directorio__ficheros"* ; do
        [[ ${file:0-1} == '*' ]] && break
        local nombre
        nombre="$(basename "$file")"

        echo "Perfil: $nombre"
        echo "----------------------------------------"

        # Mostrar copias mensuales
        echo "Copias mensuales completas:"
        local found_monthly=false
        local -a mensuales
        for backup in "${magBackup_dir}${nombre}-${hostname_suffix}"-*.tar.bz2; do
            [ -e "$backup" ] || continue
            if [[ "$(basename "$backup")" =~ -[A-Za-z]+\.tar\.bz2$ ]]; then
                found_monthly=true
                mensuales+=("$backup")
            fi
        done

        # Ordenar por fecha (más recientes primero) y mostrar
        if [ "$found_monthly" = true ]; then
            IFS=$'\n' sorted_mensuales=($(printf '%s\n' "${mensuales[@]}" | sort -r))
            unset IFS

            for backup in "${sorted_mensuales[@]}"; do
                local size
                size=$(du -h "$backup" 2>/dev/null | cut -f1)
                local fecha
                fecha=$(stat -c %y "$backup" 2>/dev/null | cut -d' ' -f1)
                echo "  $(basename "$backup") - $size - $fecha"
            done
        else
            echo "  (ninguna)"
        fi

        # Mostrar copias incrementales
        echo "Copias incrementales:"
        local found_incremental=false
        # Usar un array para poder ordenar por fecha
        local -a incrementales

        # Buscar incrementales con patrón nuevo (con hostname)
        for backup in "${magBackup_dir}${nombre}-${hostname_suffix}"-[0-9]*_*.tar.bz2; do
            [ -e "$backup" ] || continue
            if [[ "$(basename "$backup")" =~ -[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
                found_incremental=true
                incrementales+=("$backup")
            fi
        done

        # Buscar incrementales con patrón antiguo (sin hostname) para compatibilidad
        for backup in "${magBackup_dir}${nombre}"-[0-9]*_*.tar.bz2; do
            [ -e "$backup" ] || continue
            # Evitar duplicados si ya lo encontramos arriba
            local basename_backup
            basename_backup=$(basename "$backup")
            local ya_encontrado=false
            for existing in "${incrementales[@]}"; do
                if [ "$(basename "$existing")" = "$basename_backup" ]; then
                    ya_encontrado=true
                    break
                fi
            done
            if [ "$ya_encontrado" = false ] && [[ "$basename_backup" =~ ^${nombre}-[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
                found_incremental=true
                incrementales+=("$backup")
            fi
        done

        # Ordenar por fecha (más recientes primero) y mostrar
        if [ "$found_incremental" = true ]; then
            # Ordenar los incrementales por fecha (más recientes primero)
            IFS=$'\n' sorted_incrementales=($(printf '%s\n' "${incrementales[@]}" | sort -r))
            unset IFS

            for backup in "${sorted_incrementales[@]}"; do
                local size
                size=$(du -h "$backup" 2>/dev/null | cut -f1)
                local fecha_hora
                fecha_hora=$(basename "$backup" | grep -oE '[0-9]{8}_[0-9]{6}')
                local fecha_formateada
                fecha_formateada=$(echo "$fecha_hora" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)_\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
                echo "  $(basename "$backup") - $size - $fecha_formateada"
            done
        else
            echo "  (ninguna)"
        fi
        echo
    done

    # Mostrar backups descubiertos (sin perfil configurado)
    local -a perfiles_descubiertos
    while IFS= read -r perfil; do
        [ -n "$perfil" ] && perfiles_descubiertos+=("$perfil")
    done < <(magbackup_descubrir_backups)

    if [ ${#perfiles_descubiertos[@]} -gt 0 ]; then
        echo "=========================================="
        echo "Backups sin perfil configurado"
        echo "=========================================="
        echo "(Se pueden recuperar con: magBackup --recuperar <nombre>)"
        echo

        for nombre in "${perfiles_descubiertos[@]}"; do
            # Verificar si ya se mostró como perfil configurado
            local ya_mostrado=false
            for file in "$directorio__ficheros"* ; do
                [[ ${file:0-1} == '*' ]] && break
                if [ "$(basename "$file")" = "$nombre" ]; then
                    ya_mostrado=true
                    break
                fi
            done

            if [ "$ya_mostrado" = false ]; then
                echo "Backup: $nombre"
                echo "----------------------------------------"

                # Contar mensuales e incrementales
                local count_mensual=0
                local count_inc=0
                for backup in "${magBackup_dir}${nombre}"*.tar.bz2; do
                    [ -e "$backup" ] || continue
                    if [[ "$(basename "$backup")" =~ -[A-Za-z]+\.tar\.bz2$ ]]; then
                        count_mensual=$((count_mensual + 1))
                    elif [[ "$(basename "$backup")" =~ -[0-9]{8}_[0-9]{6}\.tar\.bz2$ ]]; then
                        count_inc=$((count_inc + 1))
                    fi
                done

                echo "  Copias mensuales: $count_mensual"
                echo "  Copias incrementales: $count_inc"
                echo
            fi
        done
    fi
}

while [ -n "$1" ] ; do

  case "$1" in

    -h|-help|--help) help ; exit ;;
    -info) info ; help ; exit ;;
    --dependencias|-d) comprobar_dependencias ; exit ;;
    --config|-c) config ; exit ;;
    --backup-dir|-b)
        shift
        if [ -z "$1" ]; then
            echo "Error: Debes especificar el directorio de backups"
            echo "Uso: magBackup --backup-dir <directorio> --recuperar <perfil>"
            echo ""
            echo "Ejemplo:"
            echo "  magBackup --backup-dir /mnt/backups --recuperar documentos"
            exit 1
        fi
        magBackup_dir="$1"
        # Asegurar que termine con /
        [[ "$magBackup_dir" != */ ]] && magBackup_dir="${magBackup_dir}/"
        DIR_SNAPSHOTS="${magBackup_dir}.snapshots/"
        shift
        ;;
    --recuperar|-r)
        shift
        if [ -z "$1" ]; then
            echo "Error: Debes especificar el perfil a recuperar"
            echo "Uso: magBackup --recuperar <perfil> [fecha] [directorio_destino]"
            echo "       magBackup --backup-dir <dir> --recuperar <perfil>"
            echo ""
            echo "Ejemplos:"
            echo "  magBackup --recuperar documentos                  # Recupera el mensual más reciente"
            echo "  magBackup --recuperar documentos 20260210         # Recupera hasta el 10/02/2026"
            echo "  magBackup --backup-dir /mnt/backups --recuperar documentos"
            exit 1
        fi
        PERFIL_RECUPERAR="$1"
        shift

        # Detectar si el siguiente argumento es una fecha (YYYYMMDD) o directorio
        FECHA_RECOVER=""
        DIRECTORIO_DESTINO=""

        if [ -n "$1" ]; then
            if [[ "$1" =~ ^[0-9]{8}$ ]]; then
                # Es una fecha
                FECHA_RECOVER="$1"
                shift
                DIRECTORIO_DESTINO="${1:-}"
            else
                # Es un directorio (o algo que no es fecha)
                DIRECTORIO_DESTINO="$1"
            fi
        fi

        magbackup_recuperar_backup "$PERFIL_RECUPERAR" "$FECHA_RECOVER" "$DIRECTORIO_DESTINO"
        exit $?
        ;;
    --listar|-l) magbackup_listar_perfiles ; exit ;;

  esac

done

# Si no encontramos fichero de configuración hay que generarlo
if [ ! -e "$fichero_configuracion_magbackup" ] ; then
  echo
  echo "No se encontró fichero de configuración"
  echo
  read -rp "Configurar ahora (s/n): " OPCION
  if [ "$OPCION" = "s" ] ; then
    configuracion_menu magBackup_ "$fichero_configuracion_magbackup"
  else
    exit 2
   fi
fi

# Recogemos archivo de configuración
# @todo Crear carpetas si no las hay.
DIR_CONFIG=$(dirname "$fichero_configuracion_magbackup")

if [[ ! -d "$DIR_CONFIG" ]] ; then
  mkdir -p "$DIR_CONFIG"
  mkdir -p "$directorio__ficheros"
  mkdir -p "$directorio__mysql"
  mkdir -p "$directorio__docker_postgres"
  mkdir -p "$directorio__dokku_postgres"
  mkdir -p "$directorio__dokku_mysql"

  configuracion_guardar "magBackup_" "$fichero_configuracion_magbackup"
fi

. "$fichero_configuracion_magbackup"


magbackup_crear_copia_ficheros_perfil
magbackup_crear_copia_mysql_perfil
magbackup_crear_copia_docker_postgres_perfil
magbackup_crear_copia_dokku_postgres_perfil
magbackup_crear_copia_dokku_mysql_perfil

delete_old_files
